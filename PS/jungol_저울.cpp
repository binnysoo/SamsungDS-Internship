#include <iostream>
using namespace std;

const int MAX_NUM = 1005;
const int MAX_W = 1000001;
int N, ans = 1;
int w[MAX_NUM];
bool result[MAX_W];


int main() {
	int i, j;
	cin >> N;
	w[0] = 0; result[0] = true;
	for (i = 1; i <= N; ++i) {
		cin >> w[i];
		result[w[i]] = true;
	}

	// sort
	int tmp;
	for (i = 2; i <= N; ++i) {
		tmp = w[i]; j = i - 1;
		while (j > 0 && w[j] > tmp) {
			w[j + 1] = w[j];
			j--;
		}
		w[j + 1] = tmp;
	}

	/*
	1 1 2 3 4 9 30
	1 2 4 7 11 20 50
	

	1 2 4 7  10 30
	1 3 7 14 24 54

	1 2 4 8  16
  	1 3 7 15 31

	*/


	int ans = 0; // ans = 최대로 만들 수 있는 무게 (아무것도 담지 않는 경우 0이므로 0으로 초기화)
	for (i = 1; i <= N; ++i) {
		if (ans + 1 < w[i]) break; // 만약 최대로 만들 수 있는 무게 + 1 (+ 1을 하는 이유는 만들 수 없는 "최소" 무게를 구해야 하므로) 이 다음으로 무거운 추보다 가볍다면, 
		// 이 말은, 1번째 ~  i-1 번째 추의 총 합이 i번째 추의 무게 - 1보다 가볍다는 뜻
		// 만약 그렇다면, 그 사이에 있는 값을 채울 수 있는 방법은 없다. 
		// (w[i] = x 라고 하고 w[1] + .. w[i-1] = y 라고 할 때 y < x - 1 이라면 y에 무언가를 더해서 x보다 작은 값을 만들 수 없다.
		// (현재 추는 오름차순으로 정렬되어 있기 때문에 더할 수 있는 최소 추는 x. 
		//  그런데 x 미만의 수를 만들어야 하므로 x는 더할 수 없고, y 초과의 수를 만들어야 하므로 w[[0] ~ w[i-1] 중 뺄 수 있는 추 없다.)

		// 만약 그렇지 않다면: 즉 y + 1 >= x 라면
		// 여태까지 위의 if문에 걸리지 않았다는 의미는, w[j], w[j + 1] (1 <= j < i - 1) 의 차이가 2^(i - 1) 이하였음을 의미한다.
		// (w[1], w[2] 의 차이는 1 이하, w[2], w[3]의 차이는 2 이하, w[3], w[4]의 차이는 4 이하 ...)
		// 마찬가지로 w[i - 1]와 w[i] 의 차이도 w[i -1] 이하이므로 y 초과 x 미만인 수를 만들기 위해서는 w[i]를 더하고, w[1] ~ w[i-1] 중 w[i]와 적절한 차이가 나는 추를 제거하면 된다.
		// w[0] = w[0] 
		// w[1] = w[0] + 1
		// w[2] = w[0] + w[1] + 1 = w[0] + w[0] + 1 + 1
		// w[3] = w[0] + w[1] + w[2] + 1 = w[0] + w[0] + 1 + w[0] + w[0] + 1 + 1 + 1
		// w[4] = w[0] + w[1] + w[2] + w[3] + 1 = w[0] +  w[0] + 1 + w[0] + w[0] + 1 + 1 +  w[0] + w[0] + 1 + w[0] + w[0] + 1 + 1 + 1 + 1
		// w[i] = w[0] * (i - 1) + num_of_one[i]
		// num_of_one[] = {0, 1, 2, 4, 8, ... }

		ans += w[i];
	}

	cout << ans + 1;

	return 0;
}